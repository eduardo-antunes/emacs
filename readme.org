#+title: Minha configuração do GNU emacs
#+date: 20 de novembro de 2021
#+property: header-args:emacs-lisp :tangle ./init.el :mkdirp yes

Bem-vindo, eu acho. Essa é a minha humilde configuração do emacs, um editor de texto livre desenvolvido pelo projeto GNU. Apesar de ser bastante "seco" por padrão, ele pode ser extendido e customizado das maneiras mais loucas, o que o torna incrivelmente poderoso. Eu o uso para programar e preparar documentos.

* Performance de inicialização

O emacs é, no fundo, um híbrido de editor de texto e interpretador de emacs-lisp; e como todo bom interpretador, ele executa /garbage collection/ periodicamente para minizar usos desnecessários da memória do usuário. No entanto, a frequência com que o emacs realiza essa operação é alta demais para os padrões modernos, pois foi decidida pensando em computadores com quantidades baixíssimas de ram. Para aumentar a performance, eu diminuo a frequência aqui, permitindo que o programa só faça gc quando o uso desnecessário de memória exceder 50MB.

#+begin_src emacs-lisp
  (setq gc-cons-threshold (* 50 1000 1000))
#+end_src

* Gerenciamento de pacotes

Os pacotes de emacs-lisp são a principal maneira de customizar e extender o emacs. Há um gerenciador de pacotes nativo, o =package.el=, para facilitar a instalação e o gerenciamento deles. Para que ele tenha acesso a um bom acervo de pacotes, eu o configuro para utilizar como fontes o MELPA (repositório da comunidade), o NonGNU e o ELPA (repositório oficial da GNU).

#+begin_src emacs-lisp
  (require 'package)

  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
                           ("nongnu" . "https://elpa.nongnu.org/nongnu/")
                           ("elpa"  . "https://elpa.gnu.org/packages/")))

  (package-initialize)
  (unless package-archive-contents
    (package-refresh-contents))
#+end_src

O =package.el= é ok, mas ele não oferece uma biblioteca robusta para a instalação e a configuração de pacotes. Esse papel é assumido pelo =use-package=, cujo uso permite uma configuração bem mais limpa e organizada.

#+begin_src emacs-lisp
  ;; Instalando o use-package se não estiver instalado
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

  (require 'use-package)
  (setq use-package-always-ensure t)
#+end_src

* Organização de arquivos

A organização de arquivos de configuração e de dados não é consistente entre os vários pacotes. O pacote =no-littering= soluciona esse problema configurando uma ampla seleção de pacotes para deixar suas configurações em um diretório =etc= e seus dados em um =var=, ambos localizados sob o =.emacs.d= por padrão.

#+begin_src emacs-lisp
  (use-package no-littering)

  ;; Arquivos de auto-save no var
  (setq auto-save-file-name-transforms
        `((".*" ,(no-littering-expand-var-file-name "auto-save/") t)))
#+end_src
   
* Atalhos de teclado
  
** Evil

Eu não sou um grande fã dos atalhos de edição padrão do emacs, especialmente depois de ter conhecido os atalhos ergonômicos do vim. Felizmente, o excelente pacote =evil= permite ao emacs emular a experiência confortável de edição que o vim oferece.
  
#+begin_src emacs-lisp
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)

  (use-package evil
    :init
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)
    (setq evil-want-C-u-scroll t)
    (setq evil-want-C-i-jump nil)
    :config
    (evil-mode 1)
    (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
    (define-key evil-insert-state-map (kbd "C-h") 'evil-delete-backward-char-and-join)

    ;; Use visual line motions even outside of visual-line-mode buffers
    (evil-global-set-key 'motion "j" 'evil-next-visual-line)
    (evil-global-set-key 'motion "k" 'evil-previous-visual-line)

    (evil-set-initial-state 'messages-buffer-mode 'normal)
    (evil-set-initial-state 'dashboard-mode 'normal))
#+end_src

*** Complementos do evil

O =evil-collection= aumenta a integração do =evil= com uma ampla coleção de pacotes, e o =evil-nerd-commenter= emula um dos vários plugins de comentário feitos para o vim.

#+begin_src emacs-lisp
  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init))

  (use-package evil-nerd-commenter
    :after evil
    :config (evilnc-default-hotkeys t) ;; use default key bindings (M-;) in Emacs state
    :bind (:map evil-normal-state-map
                ("gc" . evilnc-comment-or-uncomment-lines)))
#+end_src

** General

O =general.el= é um pacote análogo ao =use-package=, mas para a criação de atalhos de teclado. Eu o utilizo principalmente para criar atalhos prefixados por uma tecla-líder, à maneira do vim.

#+begin_src emacs-lisp
  (use-package general
    :after evil
    :config

    (general-create-definer ed/leader-key
      :states '(normal insert visual emacs)
      :prefix "SPC"
      :global-prefix "C-c")

    (ed/leader-key
      "SPC" #'find-file
      "."   #'dired
      ":"   '(execute-extended-command :which-key "M-x")
      "c"   '(:ignore t :which-key "compile")
      "cc"  #'compile
      "cr"  #'recompile
      "b"   #'switch-to-buffer
      "w"   '(:keymap evil-window-map :which-key "window")
      "h"   '(:keymap help-map :which-key "help")))
#+end_src

** Which-key

Às vezes é difícil lembrar de todos os atalhos de teclado. O pacote =which-key= é uma verdadeira mão na roda nessas horas.
   
#+begin_src emacs-lisp
  (use-package which-key
    :defer 0
    :config
    (which-key-mode)
    (setq which-key-idle-delay 1))
#+end_src

* Visual

Na minha opinião, o visual padrão é ok, mas eu não usaria por um período prolongado nem sob ameaça.

** Configuração básica

Eu prefiro utilizar o emacs sem nenhum elemento visual desnecessário. Nada de tela inicial também.

#+begin_src emacs-lisp
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (tooltip-mode -1)

  ;; Setup extra pra uso com o daemon
  (add-hook 'server-after-make-frame-hook #'(lambda () (scroll-bar-mode -1)
                                              (set-frame-font "Source Code Pro-12")))

  (setq inhibit-startup-screen t)
#+end_src

Mas uma pequena margem entre o texto e as bordas da tela não faz mal, e linhas numeradas são (geralmente) bem úteis.

#+begin_src emacs-lisp
  (set-fringe-mode 10)

  (column-number-mode)
  (global-display-line-numbers-mode t)
  (setq display-line-numbers-type 'relative)

  (dolist (mode '(org-mode-hook
                  term-mode-hook
                  calendar-mode-hook
                  shell-mode-hook
                  eshell-mode-hook))
    (add-hook mode (lambda () (display-line-numbers-mode 0))))
#+end_src

Finalmente, eu detesto a rolagem padrão do emacs. Rolagem suave é uma necessidade básica pra mim.

#+begin_src emacs-lisp
  (use-package smooth-scrolling
    :init (smooth-scrolling-mode 1))
#+end_src

** Tema e fonte

No momento, meu tema favorito é o doom-one da coleção =doom-themes=.

#+begin_src emacs-lisp
  (use-package doom-themes)
  (load-theme 'doom-one t)
  (set-frame-font "Source Code Pro-12" nil t)
#+end_src

** Modeline
   
Acho a =doom-modeline= bem bonita e informativa. Pra ela funcionar direitinho em novas instalações do emacs, não dá pra esquecer de executar =M-x all-the-icons-install-fonts RET=.

#+begin_src emacs-lisp
  (use-package all-the-icons)

  (use-package doom-modeline
    :init
    (doom-modeline-mode 1)
    (size-indication-mode 1)
    :custom
    (doom-modeline-major-mode-icon nil)
    (doom-modeline-buffer-encoding nil)
    (doom-modeline-buffer-file-name-style 'relative-from-project))
#+end_src

* Completion

Completion é uma palavra bem difícil de traduzir nesse contexto kkkk. Mas basicamente, existem diversas funcionalides no emacs que envolvem selecionar uma string de uma lista de candidatos. Talvez o mais clássico exemplo disso seja o =M-x=, que executa uma função elisp entre as existentes. Completion no contexto do emacs se refere à capacidade do editor de auxiliar o usuário nesses processos de seleção, seja autocompletando o que o usuário digita ou exibindo as possibilidades válidas. o framework nativo de completion funciona, mas é bem mínimo; os pacotes instalados e configurados nessa seção expandem a sua funcionalidade e tornam a experiência de utilizá-lo mais agradável.

** Vertico

Uma versão mínima do tradicional =ivy=, o vertico exibe as possibilidades válidas em um processo de seleção em uma interface bem agradável, além de expandir a funcionalidade nativa de completion. Peguei essa configuração de um amigo kkkk.

#+begin_src emacs-lisp
  (defun ed/minibuffer-backward-kill (arg)
    "Quando o minibuffer estiver completando o nome de um arquivo, delete tudo até a sua pasta-pai; do contrário, delete normalmente"
    (interactive "p")
    (if minibuffer-completing-file-name
        (if (string-match-p "/." (minibuffer-contents))
            (zap-up-to-char (- arg) ?/)
          (delete-minibuffer-contents))
      (backward-delete-char arg)))

  (use-package vertico
    :bind (:map vertico-map
                ("C-j" . vertico-next)
                ("C-k" . vertico-previous)
                ("C-l" . vertico-exit-input)
                :map minibuffer-local-map
                ("M-h" . backward-kill-word)
                ("<backspace>" . ed/minibuffer-backward-kill))
    :init
    (vertico-mode))
#+end_src

** Marginalia

O marginalia inclui anotações úteis na interface do vertico.

#+begin_src emacs-lisp
  (use-package marginalia
    :after vertico
    :init (marginalia-mode))
#+end_src

** Corfu

O corfu providencia uma interface de completion familiar aos usuários de IDEs.

#+begin_src emacs-lisp
  (use-package corfu
    :demand t
    :bind (:map corfu-map
                ("M-j" . corfu-next)
                ("M-k" . corfu-previous))
    :custom
    (corfu-cycle t)
    :config
    (setq tab-always-indent 'complete)
    (corfu-global-mode 1))
#+end_src

** Orderless

Normalmente, a pesquisa em um processo de seleção se dá de forma linear. O =orderless= muda isso.

#+begin_src emacs-lisp
  (use-package orderless
    :init
    (setq completion-styles '(orderless)
          completion-category-defaults nil
          completion-category-overrides '((file (styles . (partial-completion))))))
#+end_src

* Ferramentas

** Org

Não vou me preocupar muito em documentar no momento.

#+begin_src emacs-lisp
  (defun ed/org-mode-setup ()
    (org-indent-mode)
    (visual-line-mode 1))

  (use-package org
    :hook (org-mode . ed/org-mode-setup)
    :config
    (setq org-ellipsis " ▾"))

  (use-package org-bullets
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))

  (defun ed/org-mode-visual-fill ()
    (setq visual-fill-column-width 100
          visual-fill-column-center-text t)
    (visual-fill-column-mode 1))

  (use-package visual-fill-column
    :hook (org-mode . ed/org-mode-visual-fill))
#+end_src

** Dired

O editor de diretórios ou =dired= é o explorador de arquivos nativo do emacs.

#+begin_src emacs-lisp
  (general-def 'normal 'dired-mode-map
    "h" #'dired-up-directory
    "l" #'dired-find-file)

  (setq dired-listing-switches "-al --group-directories-first")
#+end_src

* Programação

** LSP

O /language server protocol/ (protocolo de servidores de linguagem) ou LSP é um protocolo para a comunicação entre um editor de texto e ferramentas externas de suporte para linguagens de programação (/os language servers/). O emacs não possui um cliente nativo de LSP; pelo menos não por enquanto. Felizmente, o pacote =lsp-mode= fornece essa funcionalidade, e o pacote =lsp-ui= a integra com a interface gráfica do editor.

#+begin_src emacs-lisp
  (use-package lsp-mode
    :commands (lsp lsp-deferred)
    :init
    (setq lsp-keymap-prefix "C-c l")
    :custom
    (lsp-enable-snippet nil)
    :config
    (setq lsp-headerline-breadcrumb-enable nil)
    (lsp-enable-which-key-integration))

  (use-package lsp-ui
    :hook (lsp-mode . lsp-ui-mode)
    :custom
    ;; lsp-ui documentation panels
    (lsp-ui-doc-max-height 8)
    (lsp-ui-doc-max-width 72)
    (lsp-ui-doc-delay 0.75)
    (lsp-ui-doc-show-with-cursor nil)
    (lsp-ui-doc-show-with-mouse nil)
    (lsp-ui-doc-position 'at-point)

    ;; lsp-ui sideline
    (lsp-ui-sideline-show-diagnostics t)
    (lsp-ui-sideline-show-code-actions nil)
    (lsp-ui-sideline-actions-icon lsp-ui-sideline-actions-icon-default)

    ;; lsp-ui miscelaneous
    (lsp-lens-enable t)
    (lsp-signature-render-documentation nil))
#+end_src

** Flycheck

#+begin_src emacs-lisp
  (use-package flycheck
    :hook (lsp-mode . flycheck-mode))
#+end_src

** Projetos

O pacote =projectile.el= é uma biblioteca de funções que operam ao nível de projeto, o que é muito útil em projetos de programação. Vários outros pacotes possuem boa integração com ele.

#+begin_src emacs-lisp
  (use-package projectile
    :config (projectile-mode)
    :bind-keymap ("C-c p" . projectile-command-map))
#+end_src

** Magit

Um pacote clássico do emacs. Possivelmente a melhor porcelana existente para o git.

#+begin_src emacs-lisp
  (use-package magit
    :commands (magit-status magit-get-current-branch)
    :general
    (ed/leader-key
      "g" #'magit-status))

  (use-package magit-todos ;; mostra TODOs para os arquivos em um repo
    :after magit)
#+end_src

** Pequenos complementos


O =rainbow-mode= exibe delimitadores correspondentes com uma mesma cor.

#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

O =smart-parens= previne delimitadores desbalanceados.

#+begin_src emacs-lisp
  (use-package smartparens
    :hook (prog-mode . smartparens-mode))
#+end_src
   
** Suporte de linguagens

*** C/C++

#+begin_src emacs-lisp
  (defun ed/c-cpp-mode-setup ()
    (c-set-style "cc-mode")
    (c-toggle-auto-state 1)
    (lsp-deferred))

  (add-hook 'c-mode-hook   #'ed/c-cpp-mode-setup)
  (add-hook 'c++-mode-hook #'ed/c-cpp-mode-setup)
#+end_src

*** Assembly

#+begin_src emacs-lisp
  (use-package nasm-mode
    :mode "\\.asm\\'")
#+end_src

*** Python

#+begin_src emacs-lisp
  (use-package python-mode)
  (use-package lsp-pyright
    :hook (python-mode . (lambda ()
                           (require 'lsp-pyright)
                           (lsp-deferred))))
#+end_src

*** Dart/Flutter

#+begin_src emacs-lisp
  (use-package dart-mode)

  (use-package lsp-dart
    :hook (dart-mode . lsp-deferred)
    :custom
    (lsp-dart-flutter-sdk-dir "~/Downloads/flutter")
    (lsp-dart-sdk-dir (concat lsp-dart-flutter-sdk-dir "/bin/cache/dart-sdk")))

  (use-package flutter
    :after dart-mode
    :general
    (ed/leader-key
      "mr" '(flutter-run-or-hot-reload :which-key "hot reload")))
#+end_src
   
* Geração automática do init.el

Esse arquivo que você está lendo agora mesmo é o arquivo que eu de fato edito quando configuro o emacs. No entanto, não é ele que o emacs lê quando abre, e sim o =init.el=. O código abaixo faz com que, sempre que eu salve esse documento aqui, o =init.el= seja gerado automaticamente a partir dele.

#+begin_src emacs-lisp
  (defun ed/org-babel-tangle-config ()
    (when (string-equal (file-name-directory (buffer-file-name))
                        (expand-file-name user-emacs-directory))
      (let ((org-confirm-babel-evaluate nil))
        (org-babel-tangle))))

  (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'ed/org-babel-tangle-config)))
#+end_src

* Performance de execução

Finalizado o carregamento do arquivo de configuração, o emacs pode realizar /garbage collections/ com mais frequência sem grandes impactos de performance. Portanto, eu abaixo o limite do uso desnecessário para 20MB aqui.

#+begin_src emacs-lisp
  (setq gc-cons-threshold (* 2 1000 1000))
#+end_src
